from collections import Counter

arr = [2,7,7,7,1,7,2]
counter_arr = list(Counter(arr).items())
max_counter_num = max(counter_arr,key=lambda x: x[1])[0]
if max_counter_num > len(arr) // 2:
    print(max_counter_num)
else:
    print(-1)


# 코너 케이스 고려 ( 배열이 null일 수도 있음 )
# 조건을 확실히 판단 ( 배열의 각 원소의 범위가 어떻게 되는지? 등등 )

# - 기술적 커뮤니케이션 역량
# - 효율적인 프로그래밍 작성 역량
# - 꼼꼼한 프로그래밍 작성 역량
#
# - 단순히 문제를 프로그래밍으로 풀었는지를 확인하는 것이 아님.
#
# ---
#
# ### 1. 문제 듣기
#
# - 문제 설명 관련 정보는 하나라도 놓치지 않고 들어야 함
#     - 세세한 문구 하나하나에 조건이 숨겨져 있을 수 있음
#         - 조건을 놓치면 요구되지 않은 프로그램을 작성할 수 있음
#     - 애매하게 이야기한 부분은 반드시 짚고 넘어가야 함
#         - 의도적으로 애매하게 이야기해서, 조건을 명확하게 커뮤니케이션을 통해 정의할 수 있는지를 판단.
#
#         ex) 어떠한 값에 null값이 올 수 있는지, 최대 값과 최소 값이 어떻게 되는지
#
#            ⇒ 예외 상황을 파악하여 질문 할 수 있어야 한다.
#
# ### 2. 예제를 통해 문제 이해하기
#
# - 직업 예제를 적어보고, 문제를 이해하고, 숨은 조건을 명확히 커뮤니케이션을 통해 확인함
#
#     ex) 간단한 예제 → 복잡한 예제로 순차적 접근
#
# ### 3. 무식하게 풀기
#
# - 처음부터 최적의 알고리즘을 생각하지 말 것
# - 일단 무식한 코드라도 좋으니, 코드로 작성해서 요구에 맞는 결과를 낼 것
# - 시간 복잡도를 대략적으로 계산해서 알려줄 것
#
# → 먼저 무식하게 풀어보고 패턴을 찾아 시간복잡도 향상시키기.
#
# ### 4. 질문자와 커뮤니케이션을 통해 개선하기
#
# - 개선의 포인트를 질문자와의 커뮤니케이션을 통해 찾아내기
# - 개선할만한 부분의 코드를 수정하기
# - 개선된 시간 복잡도를 대략적으로 계산해서 알려 줄것
#
# ⇒ 자신이 작성한 코드를 보고 시간 복잡도를 정확하게 계산할 줄 알아야함.
#
# ### 5. 마이너한 부분의 최적화
#
# - 병목현상, 불필요 작업, 중복 작업, 놓친 부분을 최적화하며 완벽한 코드를 만들 것
# - 방어코드를 넣을 것 ex) 배열의 길이가 0인 경우
#
# ### 6. 검토하기
#
# - 간단한 예제를 통해서 본인이 작성한 코드를 설명하고 검증하기 (버그가 있을 경우 그 버그를 수정하는 모습을 보여 주면 됨)